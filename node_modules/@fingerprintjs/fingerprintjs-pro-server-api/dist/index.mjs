/**
 * FingerprintJS Server API Node.js SDK v4.0.1 - Copyright (c) FingerprintJS, Inc, 2024 (https://fingerprint.com)
 * Licensed under the MIT (http://www.opensource.org/licenses/mit-license.php) license.
 */

import { createDecipheriv } from 'crypto';
import { inflateRaw } from 'zlib';
import { promisify } from 'util';
import { Buffer } from 'buffer';

var Region;
(function (Region) {
    Region["EU"] = "EU";
    Region["AP"] = "AP";
    Region["Global"] = "Global";
})(Region || (Region = {}));
var AuthenticationMode;
(function (AuthenticationMode) {
    AuthenticationMode["AuthHeader"] = "AuthHeader";
    AuthenticationMode["QueryParameter"] = "QueryParameter";
})(AuthenticationMode || (AuthenticationMode = {}));
function isVisitorsError(response) {
    return (((response === null || response === void 0 ? void 0 : response.hasOwnProperty('status')) &&
        (response.status === 403 || response.status === 429) &&
        (response === null || response === void 0 ? void 0 : response.hasOwnProperty('error')) &&
        typeof response.error === 'string') ||
        false);
}
function isEventError(response) {
    var _a, _b;
    return (((response === null || response === void 0 ? void 0 : response.hasOwnProperty('status')) &&
        (response.status === 403 || response.status === 404) &&
        (response === null || response === void 0 ? void 0 : response.hasOwnProperty('error')) &&
        ((_a = response.error) === null || _a === void 0 ? void 0 : _a.hasOwnProperty('message')) &&
        typeof response.error.message === 'string' &&
        ((_b = response.error) === null || _b === void 0 ? void 0 : _b.hasOwnProperty('code')) &&
        typeof response.error.code === 'string') ||
        false);
}

var version = "4.0.1";

const euRegionUrl = 'https://eu.api.fpjs.io/';
const apRegionUrl = 'https://ap.api.fpjs.io/';
const globalRegionUrl = 'https://api.fpjs.io/';
function getIntegrationInfo() {
    return `fingerprint-pro-server-node-sdk/${version}`;
}
function getEventUrl(requestId, region, apiKey) {
    const params = {
        ii: getIntegrationInfo(),
    };
    if (apiKey) {
        params.api_key = apiKey;
    }
    return `${getServerApiUrl(region)}events/${requestId}?${serializeQueryStringParams(params)}`;
}
function getVisitorsUrl(region, visitorId, filter, apiKey) {
    const queryStringParameters = Object.assign(Object.assign({}, filter), { ii: getIntegrationInfo() });
    if (apiKey) {
        queryStringParameters.api_key = apiKey;
    }
    const serverApiPath = getVisitorsPath(region, visitorId);
    const queryString = serializeQueryStringParams(queryStringParameters);
    return `${serverApiPath}?${queryString}`;
}
function serializeQueryStringParams(params) {
    const urlSearchParams = new URLSearchParams(Object.entries(params));
    return urlSearchParams.toString();
}
function getVisitorsPath(region, visitorId) {
    const serverApiUrl = getServerApiUrl(region);
    const serverApiPath = `${serverApiUrl}visitors/${visitorId}`;
    return serverApiPath;
}
function getServerApiUrl(region) {
    switch (region) {
        case Region.EU:
            return euRegionUrl;
        case Region.AP:
            return apRegionUrl;
        case Region.Global:
            return globalRegionUrl;
        default:
            throw new Error('Unsupported region');
    }
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */


function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

class FingerprintJsServerApiClient {
    /**
     * FingerprintJS server API client used to fetch data from FingerprintJS
     * @constructor
     * @param {Options} options - Options for FingerprintJS server API client
     */
    constructor(options) {
        var _a, _b;
        if (!options.region) {
            throw Error('Region is not set');
        }
        if (!options.apiKey) {
            throw Error('Api key is not set');
        }
        this.region = options.region;
        this.apiKey = options.apiKey;
        this.authenticationMode = (_a = options.authenticationMode) !== null && _a !== void 0 ? _a : AuthenticationMode.AuthHeader; // Default auth mode is AuthHeader
        this.fetch = (_b = options.fetch) !== null && _b !== void 0 ? _b : fetch;
    }
    getEvent(requestId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!requestId) {
                throw new TypeError('requestId is not set');
            }
            const url = this.authenticationMode === AuthenticationMode.QueryParameter
                ? getEventUrl(requestId, this.region, this.apiKey)
                : getEventUrl(requestId, this.region);
            const headers = this.getHeaders();
            return this.fetch(url, {
                method: 'GET',
                headers,
            })
                .then((response) => __awaiter(this, void 0, void 0, function* () {
                const jsonResponse = yield response.json();
                if (response.status !== 200) {
                    throw Object.assign(Object.assign({}, jsonResponse), { status: response.status });
                }
                return jsonResponse;
            }))
                .catch((err) => {
                if (isEventError(err)) {
                    throw err;
                }
                const error = err instanceof Error ? err.toString() : JSON.stringify(err);
                throw {
                    status: 0,
                    error: error,
                };
            });
        });
    }
    /**
     * Gets history for the given visitor
     * @param {string} visitorId - Identifier of the visitor
     * @param {VisitorHistoryFilter} filter - Visitor history filter
     */
    getVisitorHistory(visitorId, filter) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!visitorId) {
                throw TypeError('VisitorId is not set');
            }
            const url = this.authenticationMode === AuthenticationMode.QueryParameter
                ? getVisitorsUrl(this.region, visitorId, filter, this.apiKey)
                : getVisitorsUrl(this.region, visitorId, filter);
            const headers = this.getHeaders();
            return this.fetch(url, {
                method: 'GET',
                headers,
            })
                .then((response) => __awaiter(this, void 0, void 0, function* () {
                const jsonResponse = yield response.json();
                if (response.status === 200) {
                    return jsonResponse;
                }
                if (response.status === 429) {
                    const retryAfter = response.headers.get('retry-after') || '';
                    jsonResponse.retryAfter = retryAfter === '' ? 1 : parseInt(retryAfter);
                }
                throw Object.assign(Object.assign({}, jsonResponse), { status: response.status });
            }))
                .catch((err) => {
                if (isVisitorsError(err)) {
                    throw err;
                }
                throw {
                    status: 0,
                    error: new Error(err.toString()),
                };
            });
        });
    }
    getHeaders() {
        return this.authenticationMode === AuthenticationMode.AuthHeader ? { 'Auth-API-Key': this.apiKey } : undefined;
    }
}

class UnsealError extends Error {
    constructor(key, error) {
        let msg = `Unable to decrypt sealed data`;
        if (error) {
            msg = msg.concat(`: ${error.message}`);
        }
        super(msg);
        this.key = key;
        this.error = error;
        this.name = 'UnsealError';
    }
}
class UnsealAggregateError extends Error {
    constructor(errors) {
        super('Unable to decrypt sealed data');
        this.errors = errors;
        this.name = 'UnsealAggregateError';
    }
    addError(error) {
        this.errors.push(error);
    }
    toString() {
        return this.errors.map((e) => e.toString()).join('\n');
    }
}

const asyncInflateRaw = promisify(inflateRaw);
var DecryptionAlgorithm;
(function (DecryptionAlgorithm) {
    DecryptionAlgorithm["Aes256Gcm"] = "aes-256-gcm";
})(DecryptionAlgorithm || (DecryptionAlgorithm = {}));
const SEALED_HEADER = Buffer.from([0x9e, 0x85, 0xdc, 0xed]);
function isEventResponse(data) {
    return Boolean(data && typeof data === 'object' && 'products' in data);
}
function parseEventsResponse(unsealed) {
    const json = JSON.parse(unsealed);
    if (!isEventResponse(json)) {
        throw new Error('Sealed data is not valid events response');
    }
    return json;
}
/**
 * Decrypts the sealed response with the provided keys.
 * The SDK will try to decrypt the result with each key until it succeeds.
 * To learn more about sealed results visit: https://dev.fingerprint.com/docs/sealed-client-results
 */
function unsealEventsResponse(sealedData, decryptionKeys) {
    return __awaiter(this, void 0, void 0, function* () {
        const unsealed = yield unseal(sealedData, decryptionKeys);
        return parseEventsResponse(unsealed);
    });
}
function unseal(sealedData, decryptionKeys) {
    return __awaiter(this, void 0, void 0, function* () {
        if (sealedData.subarray(0, SEALED_HEADER.length).toString('hex') !== SEALED_HEADER.toString('hex')) {
            throw new Error('Invalid sealed data header');
        }
        const errors = new UnsealAggregateError([]);
        for (const decryptionKey of decryptionKeys) {
            switch (decryptionKey.algorithm) {
                case DecryptionAlgorithm.Aes256Gcm:
                    try {
                        return yield unsealAes256Gcm(sealedData, decryptionKey.key);
                    }
                    catch (e) {
                        errors.addError(new UnsealError(decryptionKey, e));
                        continue;
                    }
                default:
                    throw new Error(`Unsupported decryption algorithm: ${decryptionKey.algorithm}`);
            }
        }
        throw errors;
    });
}
function unsealAes256Gcm(sealedData, decryptionKey) {
    return __awaiter(this, void 0, void 0, function* () {
        const nonceLength = 12;
        const nonce = sealedData.subarray(SEALED_HEADER.length, SEALED_HEADER.length + nonceLength);
        const authTagLength = 16;
        const authTag = sealedData.subarray(-authTagLength);
        const ciphertext = sealedData.subarray(SEALED_HEADER.length + nonceLength, -authTagLength);
        const decipher = createDecipheriv('aes-256-gcm', decryptionKey, nonce).setAuthTag(authTag);
        const compressed = Buffer.concat([decipher.update(ciphertext), decipher.final()]);
        const payload = yield asyncInflateRaw(compressed);
        return payload.toString();
    });
}

export { AuthenticationMode, DecryptionAlgorithm, FingerprintJsServerApiClient, Region, UnsealAggregateError, UnsealError, getEventUrl, getVisitorsUrl, isEventError, isVisitorsError, parseEventsResponse, unseal, unsealEventsResponse };
